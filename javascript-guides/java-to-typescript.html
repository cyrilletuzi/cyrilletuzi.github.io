<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Java to JavaScript / TypeScript guide by Cyrille Tuzi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="../stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" href="../stylesheets/highlight-default-9.5.0.min.css">
    <style>
        pre {
            display: flex;
            justify-content: space-around;
        }
    </style>
  </head>
  <body>

    <header class="page-header">
      <h1 class="project-name">Java to JavaScript / TypeScript guide</h1>
    </header>

    <div class="main-content">

      <p><a href="./">General explanation of the how and why of this guide available here, with other guides.</a></p>

      <main>

      <article>

      <h3>Why TypeScript ?</h3>

      <p>As a Java developer, you'll love TypeScript. ES6 brings many new tools 
        (like classes syntax, modules imports and exports...), bringing JavaScript closer to Java
        for big and serious developments, but some features are still missing (like static data types and 
        some basic tools in object oriented programming), and, I tell you, you'll be very frustrated about that.</p>

      <p>TypeScript adds these missing features in a very clever way. 
        Valid vanilla JavaScript is valid TypeScript : the new features are completely optional,
        and you can come back to pure JS at any time.</p>

      <p>Of course, you'll need to transform TypeScript in standard JavaScript for the browsers, 
        but for now you'd need to transform ES6 to ES5 anyway for browsers compatibility reasons
        (and as a Java developer, you'll rather be happy about a build step instead of afraid).</p>

      <p>This guide tells clearly when a feature is TypeScript specific. Eveything else is standard JavaScript.</p>
      
      <h3>Data declarations</h3>

      <p>In JavaScript, variables can be declared globally and values are always mutable. 
          In ES6, use only the <code class="js">let</code> keyword.</p>
      
      <pre>
        <code class="java">String myData = 'java';
myData = 'new value'; // Error</code>
        <code class="ts">let myData = 'js';
myData = 'new value'; // OK</code>
      </pre>

      <p>ES6 introduces global constants in JavaScript. Complex values can be used and therefore manipulated.</p>
      
      <pre>
<code class="java">final String MY_DATA = 'java';</code>
<code class="ts">const MY_DATA = 'js';
const MY_USER = new User(); // OK
MY_USER.name = 'New name';</code>
      </pre>

      <h3>Simple data types</h3>

      <p>In vanilla JavaScript, data types are dynamic (a variable can change its type at any time),
         and you don't need to specify them (they are automatically detected). 
        TypeScript adds manifest and static types. All numbers share the same type in JavaScript.</p>
      
      <pre>
<code class="java">boolean userMan = true;
int userAge = 81;
float userAverage = 10.5;
String userName = 'Henri Bergson';</code>
<code class="ts">let userMan: boolean = true;
let userAge: number = 81;
let userAverage: number = 10.5;
let userName: string = 'Henri Bergson';</code>
      </pre>

      <p>In addition to <code class="js">null</code>, JavaScript has the <code class="js">undefined</code> type, 
        and <code class="js">NaN</code> (Not a Number). They are errors, so do <b>not</b> use them.</p>

      <h3>String details</h3>

      <p>ES6 introduces new backtick quotes for variable interpolation and allowing line breaks.
        Avoid classic concatenation in JavaScript, as it's confusing with additions and will lead to type errors.
      </p>

      <pre>
<code class="java">String userFullName  = 
  userFirstName + ' ' + userLastName;</code>
<code class="ts">let userFullName: string = 
  `${userFirstName} ${userLastName}`;</code>
      </pre>

      <p>Also useful to manage simple and double quotes in the same string.</p>

      <pre>
<code class="ts">let HTMLTemplate: string = `&lt;p class="content"&gt;I'm Henri !&lt;/p&gt;`;</code>
      </pre>

      <h3>Data lists</h3>

      <p>Size of arrays is always dynamic in JavaScript.</p>

      <pre>
<code class="java">ArrayList&lt;String&gt; userBooks = 
  new ArrayList&lt;String&gt;();
userBooks.add('Book 1');
userBooks.get(0);
userBooks.size();</code>
<code class="ts">let userBooks: string[] = 
  ['Book 1', 'Book 2'];
userBooks.push('Book 3');
userBooks[0];
userBooks.length;</code>
      </pre>

      <p>Hash maps are called objects in JavaScript, with string keys.</p>

      <pre>
<code class="java">HashMap&lt;String, String&gt; user = 
  new HashMap&lt;String, String&gt;();
user.put('firstName', 'Henri');
user.put('lastName', 'Bergson');
user.get('firstName');
</code>
<code class="ts">let user = {
  firstName: 'Henri', 
  lastName: 'Bergson'
};
user.firstName;
</code>
      </pre>

      <h3>Blocks</h3>

      <p>Same syntax for conditions.</p>

      <p>In ES6, thanks to <code class="js">let</code>, variables are block-scoped.</p>

      <pre>
<code class="ts">for (var i: number = 0; i < 10; i++) {}
i; // 10, error prone</code>
<code class="ts">for (let i: number = 0; i < 10; i++) {}
i; // undefined</code>
      </pre>

      <p>Iteration is simplified in ES6. 
        Do not indicate the type of <code class="ts">value</code> in TypeScript (it's automatically detected).</p>

      <pre>
<code class="java">for (String value: userBooks) {}</code>
<code class="ts">for (let value of userBooks) {}</code>
      </pre>

      <p>Another option for complex iterations (with values <i>and</i> keys).</p>

      <pre>
<code class="java">for (int i = 0; i < books.size(); i++) {
    books.get(i);
}</code>
<code class="ts">books.foreach(
  function (value: string, index: number) {});</code>
      </pre>

      <h3>Functions</h3>

      <p>In JavaScript, you can access parent scopes directly.</p>

      <pre>
<code class="java">String myData = 'java';
void myMethod() {
  myData; // null
}</code>
<code class="ts">let myData: string = 'js';
function myMethod(): void {
  myData; // 'js'
}</code>
      </pre>

      <p>No overriding in JavaScript (a function can only have one definition), 
          and parameters are always optional. ES6 introduces default values.
          TypeScript allow automatic required arguments without manual checking 
          (one of the only major differences with vanilla JS).
      </p>

      <pre>
<code class="java">void myMethod(String required) {
  myMethod(required, 'default');
}
void myMethod
  (String required, String optional) {}</code>
<code class="ts">function myMethod
  (required: string, 
    optional: string = 'default'): void {}</code>
      </pre>

      <p>ES6 introduces a shorter anonymous functions syntax, named arrow functions.</p>

      <pre>
<code class="ts">numbersList.map((value: number) => value * 2);</code>
      </pre>

      <h3>Built-in methods</h3>

      <p>Some basic methods.</p>

      <pre>
<code class="java">myEmail.strpos('@');
myEmail.replaceAll('(.*)@(.*)', ' at ');
myEmail.substr(0, 5);
Integer.parseInt('10');</code>
<code class="ts">myEmail.strpos('@');
myEmail.replace('@', ' at ');
myEmail.substr(0, 5);
parseInt('10');</code>
      </pre>

      <p>When a function seems to be called directly, like <code class="js">parseInt()</code>, 
      it's because the global object is implicit : <code class="js">window.parseInt()</code>.
      <b>Do</b> use the shorthand, as the global object is not always <code class="js">window</code>.
      
      <h3>Classes</h3>

      <p>ES6 introduces classes syntax, to simplify object oriented programming in JavaScript. 
        Properties are directly created in the constructor. 
        Pre-declared properties and visibility modifiers are missing in ES6 : 
        they may appear in future JavaScript versions, but TypeScript allows them right now.</p>

      <pre>
<code class="java">public class User {
  public String firstName;
  public User(String firstName) {
    this.firstName = firstName;
  }
  public void sayHello() {}
}

User myUser = new User('Henri');
myUser.firstName;
myUser.sayHello();</code>
<code class="ts">class User {
  public firstName: string;
  public constructor(firstName: string) {
    this.firstName = firstName;
  }
  public sayHello(): void {}
}

let myUser: User = new User('Henri');
myUser.firstName;
myUser.sayHello();</code>
      </pre>

      <p>In JavaScript inheritance, parent call is <b>required</b> in the child constructor.</p>

      <pre>
<code class="java">public class Editor extends User {
  public Editor(String firstName) {
    super(firstName);
  }
  public void sayHello() {
    super.sayHello();
  }
}</code>
<code class="ts">class Editor extends User {
  public constructor(firstName: string) {
    super(firstName);
  }
  publix sayHello(): void {
    super.sayHello();
  }
}</code>
      </pre>

      <p>Getters and setters have a special syntax in JavaScript (but you can do classic accessors too).
          Do not pre-declared the property, it is done internally.</p>

      <pre>
<code class="java">public class User {
  protected String name;
  public String getName() {
    return this.name;
  }
  public void setName(String newName) {
    this.name = newName;
  }
}

User myUser = new User('Henri');
myUser.getName();
myUser.setName('New name');</code>
<code class="ts">class User {
  protected _name: string;
  public get name(): string {
    return this._name;
  }
  public set name(newName: string) {
    this._name = newName;
  }
}

let myUser: User = new User('Henri');
myUser.name;
myUser.name = 'New name';</code>
      </pre>

      <p>Same syntax for static methods in ES6.
          Same syntax for static properties and abstract classes in TypeScript.
          TypeScript also adds interfaces.</p>

      <pre>
<code class="java">public interface Movable {
  public void move();
}

public class Vehicle implements Movable {
    public void move() {}
}</code>
<code class="ts">interface Movable {
  public move(): void;
}

class Vehicle implements Movable {
    public move(): void {}
}</code>
      </pre> 
      
      <h3>Namespaces</h3>

      <p>Namespacing is directly managed by the loading system in ES6 : 
        if there is the <code class="js">export</code> or <code class="js">import</code> keyword, 
        then you are not anymore in the global scope.
        Be careful : <code>.js</code> extension is required in ES6 imports, but in TypeScript, 
        as you'll need to manage both <code>.ts</code> in development and <code>.js</code> in production, 
        it's better to configure the loader to automatically add the right extension.</p>

      <pre>
<code class="java">// User.java
package accounts;

public class User {}

// script.java
import accounts.User;

User myUser = new User();</code>
<code class="ts">// User.ts


export class User {}

// script.ts
import { User } from './module';

let myUser: User = new User();</code>
      </pre>

      <h3>JavaScript courses</h3>

      <p>If you're looking for JavaScript full courses in France, check my <a href="https://formationjavascript.com/" target="_blank">training website</a>.</p>

      </article>

      </main>

      <footer class="site-footer">
        <span class="site-footer-credits">A project by <a href="https://www.cyrilletuzi.com/en/web/" target="_blank">Cyrille Tuzi</a>. This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </div>

    <script src="../scripts/highlight-custom-9.5.0.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </body>
</html>